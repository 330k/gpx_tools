
<html>
<head>
<meta charset="utf-8">
<title>GPX to TCX Converter</title>
<meta property="og:title" content="GPX to TCX Converter" />
<meta property="og:description" content="GPXからTCXファイルに変換するツールです。wpt要素をCoursePoint要素に変換します。" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://www.330k.info/" />
<meta property="og:image" content="https://www.330k.info/apple-touch-icon.png"/>
<!--<meta name="viewport" content="width=640">-->
<script>
/**
 * Hubeny測地線距離計算式
 * @param {number} lat1
 * @param {number} lon1
 * @param {number} lat2
 * @param {number} lon2
 * @return {number} distance [m]
 */
const hubeny = (function(){
  const a = 6378137.0;
  const f = 1 / 298.257223563;
  const e2 = f * (2 - f);
  const degree = Math.PI / 180.0;
  const sin = Math.sin;
  const cos = Math.cos;
  const sqrt = Math.sqrt;
  return function (lat1, lon1, lat2, lon2){
    const latdiff = (lat1 - lat2) * degree;
    const londiff = (lon1 - lon2) * degree;
    const latave = 0.5 * (lat1 + lat2) * degree;
    const sinlatave = sin(latave);
    const coslatave = cos(latave);
    const w2 = 1.0 - sinlatave * sinlatave * e2;
    const w = sqrt(w2);
    const meridian = a * (1 - e2) / (w2 * w);
    const n = a / w;

    return sqrt(
      latdiff * latdiff * meridian * meridian +
      londiff * londiff * n * n * coslatave * coslatave
    );
  };
})();

/**
 * 緯度経度から地心直交座標系(X, Y, Z)に変換
 */
function latlon2XYZ(lat, lon){
  const a = 6378137.0;
  const b = 6356752.314245;
  const f2 = b * b / (a * a);
  const e2 = 1.0 - f2;
  const degree = Math.PI / 180.0;
  
  const latrad = lat * degree;
  const lonrad = lon * degree;
  
  const sinlat = Math.sin(latrad);
  const coslat = Math.cos(latrad);
  const sinlon = Math.sin(lonrad);
  const coslon = Math.cos(lonrad);
  
  const w2 = 1.0 - sinlat * sinlat * e2;
  const w = Math.sqrt(w2)
  const N = a / w;
  const h = 0.0;
  
  return {
    "X": (N + h) * coslat * coslon,
    "Y": (N + h) * coslat * sinlon,
    "Z": N * f2 * sinlat,
  };
}

/**
 * 線分と点の距離、線分上の最短距離を与える点の座標、内分比を返す(3次元)
 */
function segmentPointDistance3D(ax, ay, az, bx, by, bz, px, py, pz){
  let t = (ax * ax + ay * ay + bx * px - ax * (bx + px) + by * py - ay * (by + py) + (az - bz) * (az - pz))/((ax - bx) * (ax - bx) + (ay - by) * (ay - by) + (az - bz) * (az - bz));
  let x;
  let y;
  let z;
  
  if(t > 1){
    t = 1;
  }else if(t < 0){
    t = 0;
  }
  
  x = ax - (ax - bx) * t;
  y = ay - (ay - by) * t;
  z = az - (az - bz) * t;
  
  return {
    "dist": Math.sqrt((x - px) * (x - px) + (y - py) * (y - py) + (z - pz) * (z - pz)),
    "x": x,
    "y": y,
    "z": z,
    "t": t
  };
}

/**
 * DateをTCXファイル用のISO-8869形式の文字列に変換(秒は整数表記)
 */
function toTCXISOString(d){
  const d2 = new Date(d);
  if(d2.getMilliseconds() >= 500){
    d2.setSeconds(d2.getSeconds() + 1);
  }
  d2.setMilliseconds(0);
  
  return d2.toISOString().replace(/\.\d\d\dZ/, 'Z');
}

/**
 * XMLファイルを読み込むPromiseを返す
 * @param {string} file 読み込むファイル
 * @return {XMLDocument} 読み込んだ結果をXMLObjectを返すPromise
 */
function readXML(file){
  return new Promise(function(resolve, reject){
    try{
      const reader = new FileReader();
      const parser = new DOMParser();

      reader.onload = function(){
        resolve(parser.parseFromString(reader.result, "text/xml"));
      };
      reader.readAsText(file, "utf-8");
      
    }catch(e){
      reject(e);
    }
  });
}

/**
 * GPXファイルを読み込んでコースの緯度経度座標の配列とコースポイントの配列のデータにする
 * @param {XMLDocument} gpx
 * @param {number} speed 計算に使用する移動速度 [m/s]
 * @return {[{name:string,coords:[],coursepoints:[]}]}
 */
function parseGPX(gpx, speed = 15.0 / 3.6){
  const buf = [];
  
  const trkpts = gpx.querySelectorAll("trkpt");
  if(trkpts.length === 0){
    return;
  }

  const name = gpx.querySelector("trk > name").textContent;
  const coords = [];

  // trkpt要素を走査
  let d = 0.0;
  for(let i = 0; i < trkpts.length; i++){
    let lat = trkpts[i].getAttribute("lat") - 0;
    let lon = trkpts[i].getAttribute("lon") - 0;
    let ele = null;
    let XYZ = latlon2XYZ(lat, lon);
    
    if(trkpts[i].querySelector("ele")){
      ele = trkpts[i].querySelector("ele").textContent - 0;
    }
    if(i >= 1){
      d += hubeny(coords[coords.length - 1].lat, coords[coords.length - 1].lon, lat, lon);
    }
    coords.push({
      lat: lat,
      lon: lon,
      ele: ele,
      dist: d,
      time: d / speed * 1000,
      X: XYZ.X,
      Y: XYZ.Y,
      Z: XYZ.Z,
    });
  }
  
  // wpt要素を列挙して最近傍点の距離と時刻を計算
  const wpts = gpx.querySelectorAll("wpt");
  const coursepoints = [];
  const dividepoints = [{
    name: null,
    lat: coords[0].lat,
    lon: coords[0].lon,
    dist: coords[0].dist,
    time: coords[0].time,
    index: 0,
    t: 0
  }];
  
  for(let i = 0; i < wpts.length; i++){
    let lat = wpts[i].getAttribute("lat") - 0;
    let lon = wpts[i].getAttribute("lon") - 0;
    let XYZ = latlon2XYZ(lat, lon);
    
    // コースポイントの距離を判定
    let nearest = {
      index: -1,
      t: 0,
      dist_dev: Number.MAX_VALUE
    };
    for(let j = 0; j < coords.length - 1; j++){
      let v = segmentPointDistance3D(coords[j].X, coords[j].Y, coords[j].Z, coords[j + 1].X, coords[j + 1].Y, coords[j + 1].Z, XYZ.X, XYZ.Y, XYZ.Z);
      
      if(v.dist < nearest.dist_dev){
        nearest.index = j;
        nearest.t = v.t;
        nearest.dist_dev = v.dist;
      }
    }
    console.log(nearest);
    let name = wpts[i].querySelector("name").textContent;
    let dist = (1 - nearest.t) * coords[nearest.index].dist + nearest.t * coords[nearest.index + 1].dist;
    let time = dist / speed * 1000;
    
    if(name.match(/Segment/)){
      // 特定の名前のwpt要素はルート分割点とする
      dividepoints.push({
        name: name,
        lat: lat,
        lon: lon,
        dist: dist,
        time: time,
        index: nearest.index,
        t: nearest.t
      });
      console.log(dividepoints[dividepoints.length - 1]);
    }else{
      coursepoints.push({
        name: name,
        lat: lat,
        lon: lon,
        dist: dist,
        time: time
      });
      //console.log(coursepoints[coursepoints.length - 1]);
    }
  }
  dividepoints.push({
    name: null,
    lat: coords[coords.length - 1].lat,
    lon: coords[coords.length - 1].lon,
    dist: coords[coords.length - 1].dist,
    time: coords[coords.length - 1].time,
    index: coords.length - 1,
    t: 0
  });
  
  // 距離順に並び替える(そうしないとEdgeが正しく認識しない)
  coursepoints.sort((a, b) => a.dist - b.dist);
  dividepoints.sort((a, b) => a.dist - b.dist);
  
  // dividepointでルート分割
  const date_start = Math.floor(Date.now() * 0.001) * 1000;
  const result = [];
  
  console.log(dividepoints);
  
  for(let i = 0; i < dividepoints.length - 1; i++){
    let cs = [...coords.slice(dividepoints[i].index + 1, dividepoints[i + 1].index + 1)];
    let ps = [...coursepoints.filter((e) => ((dividepoints[i].dist <= e.dist) && (e.dist < dividepoints[i + 1].dist)))];
    
    if(dividepoints[i].t === 0){
      cs.unshift(coords[dividepoints[i].index]);
    }else{
      // 始点でt != 0のときは分割点をコースの先頭に加える(とりあえず擬円筒図法で内分)
      cs.unshift({
        lat: (1 - dividepoints[i].t) * coords[dividepoints[i].index].lat + dividepoints[i].t * coords[dividepoints[i].index + 1].lat,
        lon: (1 - dividepoints[i].t) * coords[dividepoints[i].index].lon + dividepoints[i].t * coords[dividepoints[i].index + 1].lon,
        dist: dividepoints[i].dist,
        time: dividepoints[i].time,
        ele: (1 - dividepoints[i].t) * coords[dividepoints[i].index].ele + dividepoints[i].t * coords[dividepoints[i].index + 1].ele
      });
    }
    if(dividepoints[i + 1].t !== 0){
      // 終点でt != 0のときは分割点をコースの末尾に加える
      cs.push({
        lat: (1 - dividepoints[i + 1].t) * coords[dividepoints[i + 1].index].lat + dividepoints[i + 1].t * coords[dividepoints[i + 1].index + 1].lat,
        lon: (1 - dividepoints[i + 1].t) * coords[dividepoints[i + 1].index].lon + dividepoints[i + 1].t * coords[dividepoints[i + 1].index + 1].lon,
        dist: dividepoints[i + 1].dist,
        time: dividepoints[i + 1].time,
        ele: (1 - dividepoints[i + 1].t) * coords[dividepoints[i + 1].index].ele + dividepoints[i + 1].t * coords[dividepoints[i + 1].index + 1].ele
      });
    }
    
    // 時刻と距離を修正
    let dist_base = cs[0].dist;
    let time_base = cs[0].time;
    for(const c of cs){
      c.dist = c.dist - dist_base;
      c.time = c.time - time_base + date_start;
    }
    for(const p of ps){
      p.dist = p.dist - dist_base;
      p.time = p.time - time_base + date_start;
    }
    
    result.push({
      name: (dividepoints.length > 2) ? (name + "_" + ("0" + (i + 1)).slice(-2)) : name,
      coords: cs,
      coursepoints: ps
    });
  }
  console.log(result);
  
  return result;
}

/**
 * TCX文字列を出力
 * @param {{name:string,coords:Array,coursepoints:Array}}
 * @return {string}
 */
function exportTCX(course){
  const buf = [];
  
  buf.push('<?xml version="1.0" encoding="UTF-8"?>');
  buf.push('<TrainingCenterDatabase xmlns="http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2 http://www8.garmin.com/xmlschemas/TrainingCenterDatabasev2.xsd">');
  buf.push('<Folders><Courses><CourseFolder Name="330k.info"><CourseNameRef><Id>' + name + '</Id></CourseNameRef></CourseFolder></Courses></Folders>');
  buf.push('<Courses>');
  buf.push('  <Course>');
  buf.push('    <Name>' + course.name + '</Name>');
  buf.push('    <Lap>');
  buf.push('      <TotalTimeSeconds>' + ((course.coords[course.coords.length - 1].time - course.coords[0].time) / 1000).toFixed(1) + '</TotalTimeSeconds>');
  buf.push('      <DistanceMeters>' + course.coords[course.coords.length - 1].dist.toFixed(8) + '</DistanceMeters>');
  buf.push('      <BeginPosition>');
  buf.push('        <LatitudeDegrees>' + course.coords[0].lat.toFixed(8) + '</LatitudeDegrees>');
  buf.push('        <LongitudeDegrees>' + course.coords[0].lon.toFixed(8) + '</LongitudeDegrees>');
  buf.push('      </BeginPosition>');
  buf.push('      <EndPosition>');
  buf.push('        <LatitudeDegrees>' + course.coords[course.coords.length - 1].lat.toFixed(8) + '</LatitudeDegrees>');
  buf.push('        <LongitudeDegrees>' + course.coords[course.coords.length - 1].lon.toFixed(8) + '</LongitudeDegrees>');
  buf.push('      </EndPosition>');
  buf.push('      <Intensity>Active</Intensity>');
  buf.push('    </Lap>');
  
  buf.push('    <Track>');
  for(const p of course.coords){
    buf.push('      <Trackpoint>');
    buf.push('        <Time>' + toTCXISOString(new Date(p.time)) + '</Time>');
    buf.push('        <Position>');
    buf.push('          <LatitudeDegrees>' + p.lat.toFixed(8) + '</LatitudeDegrees>');
    buf.push('          <LongitudeDegrees>' + p.lon.toFixed(8) + '</LongitudeDegrees>');
    buf.push('        </Position>');
    if(p.ele !== null){
      buf.push('        <AltitudeMeters>' + p.ele.toFixed(3) + '</AltitudeMeters>');
    }
    buf.push('        <DistanceMeters>' + p.dist.toFixed(3) + '</DistanceMeters>');
    buf.push('      </Trackpoint>');
  }
  buf.push('    </Track>');
  
  for(const p of course.coursepoints){
    buf.push('    <CoursePoint>');
    buf.push('      <Name>' + p.name + '</Name>');
    buf.push('      <Time>' + toTCXISOString(new Date(p.time)) + '</Time>');
    buf.push('      <Position>');
    buf.push('        <LatitudeDegrees>' + p.lat.toFixed(8) + '</LatitudeDegrees>');
    buf.push('        <LongitudeDegrees>' + p.lon.toFixed(8) + '</LongitudeDegrees>');
    buf.push('      </Position>');
    buf.push('      <PointType>Generic</PointType>');
    buf.push('    </CoursePoint>');
  }
  
  buf.push('  </Course>');
  buf.push('</Courses>');
  buf.push('</TrainingCenterDatabase>');

  
  return buf.join("\n");
}

function downloadTCX(content, filename){
  const e = document.createElement("a");
  let blob;
  
  try{
    blob = new Blob([content], {type:"application/xml"});
    
  }catch(err){
    let bb = new BlobBuilder();
    bb.append(content);
    blob = bb.getBlob("application/xml");
    
  }
  e.href = window.URL.createObjectURL(blob);
  e.setAttribute("target", "_blank");
  e.setAttribute("download", filename);
  document.body.appendChild(e);
  
  e.click();
}

window.addEventListener("DOMContentLoaded", function(){
  // GPX読み込み(基準ルート)
  document.getElementById("gpx_file").addEventListener("change", async function(evt){
    try{
      showLoader();
      const speed = (document.getElementById("input_speed").value - 0) / 3.6;

      for(const file of evt.target.files){
        const gpx = await readXML(file);
        const courses = parseGPX(gpx, speed);
        
        for(const course of courses){
          const tcx = exportTCX(course);
          downloadTCX(tcx, course.name + ".tcx");
        }
      }

    }catch(err){
      console.error(err);

    }finally{
      hideLoader();
      
    }
  });
  
  // ドラッグドロップ対応
  {
    const droparea = document.body;
    const target = document.getElementById("gpx_file");
    const overlay = document.createElement("div");
    
    overlay.id = "overlay";
    overlay.style.position = "fixed";
    overlay.style.top = "0";
    overlay.style.left = "0";
    overlay.style.width = "100%";
    overlay.style.height = "100%";
    overlay.style.zIndex = "9999";
    overlay.style.backgroundColor = "#ddd";
    overlay.style.opacity = "0.5";
    overlay.style.display = "none";
    
    droparea.appendChild(overlay);
    droparea.addEventListener("dragover", function(e){
      e.stopPropagation();
      e.preventDefault();
      overlay.style.display = "block";
    }, false);
    overlay.addEventListener("dragleave", function(e){
      e.stopPropagation();
      e.preventDefault();
      overlay.style.display = "none";
    }, false);
    overlay.addEventListener("drop", function(e){
      e.stopPropagation();
      e.preventDefault();
      overlay.style.display = "none";
      
      target.files = e.dataTransfer.files;

      target.dispatchEvent(new Event("change"));
    }, false);
  }
  
  hideLoader();
});

function hideLoader(){
  document.getElementById("loader_bg").style.display = "none";
}

function showLoader(){
  document.getElementById("loader_bg").style.display = "block";
}

/**
 * iframeで埋め込まれたときに親ウィンドウに自身の高さ情報を渡し、リサイズを要求
 */
(function(){
  const notifyResize = function (){
    const target = parent.postMessage ? parent : (parent.document.postMessage ? parent.document : undefined);
    if (typeof target !== "undefined") {
      target.postMessage(JSON.stringify({
        "message": "resize",
        "height": document.body.scrollHeight
      }), "*");
    }
  };
  window.addEventListener("load", function(){
    setTimeout(notifyResize, 50);
  });
  window.addEventListener("resize", notifyResize);
})();
</script>
<link rel="stylesheet" href="https://unpkg.com/purecss@2.1.0/build/pure-min.css" integrity="sha384-yHIFVG6ClnONEA5yB5DJXfW2/KC173DIQrYoZMEtBvGzmf0PKiGyNEqe9N6BNDBH" crossorigin="anonymous">
<style>
/* * { margin: 0; padding: 0}*/
#wrapper {
  /*width: 100%;
  height: 100%;*/
  overflow: hidden;
  padding: 10px;
  border: 1px solid gray;
  border-radius: 10px;
  box-sizing: border-box;
}
#loader_bg {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(1, 1, 1, 0.25);
  z-index: 9999;
}
#loader {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  padding: 10px;
  border-radius: 30px;
  background: #ddd;
}

#gpx_file { 
  /*display: none;*/
}
</style>
</head>
<body>
<div id="wrapper">
<div class="pure-form pure-form-aligned">
 <div class="pure-control-group">
  <label for="gpx_file">GPXファイル</label>
  <input type="file" id="gpx_file" accept=".gpx" multiple>
 </div>
 <div class="pure-control-group">
  <label for="input_speed">移動速度</label>
  <input type="number" id="input_speed" value="15" min="1" max="99">
  <span>[km/h]</span>
 </div>
 <p>GPXファイルを選択 or ドロップすると、自動的にTCXファイルに変換します(複数ファイル対応)。<br>変換後は自動的にダウンロードを開始します。</p>
</div>
<div id="loader_bg">
<div id="loader">
<img src="data:image/svg+xml,%3Csvg width='32' height='32' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' preserveAspectRatio='xMidYMid' class='uil-spin'%3E%3Cpath fill='none' class='bk' d='M0 0h100v100H0z'/%3E%3Cg transform='translate(84 50)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3Cg transform='rotate(45 -52.355 126.397)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0.12s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0.12s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3Cg transform='rotate(90 -17 67)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0.25s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0.25s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3Cg transform='rotate(135 -2.355 42.397)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0.37s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0.37s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3Cg transform='rotate(180 8 25)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0.5s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0.5s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3Cg transform='rotate(-135 18.355 7.603)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0.62s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0.62s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3Cg transform='rotate(-90 33 -17)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0.75s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0.75s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3Cg transform='rotate(-45 68.355 -76.397)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0.87s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0.87s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3C/svg%3E" width="128" height="128">
</div>
</div>
<div id="overlay"></div>
<div id="dist_info"></div>
</body>
</html>
